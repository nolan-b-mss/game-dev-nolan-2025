<!DOCTYPE html>
<html>
<head>
    <title>My Animated Crown</title>
</head>
<body>
    <canvas id="myCrownCanvasID" width="300" height="200" style="border: 1px solid gold;"></canvas>
    
    <script>
        // --- Setup ---
        const myCanvasID = 'myCrownCanvasID';
        const myCanvasElement = document.getElementById(myCanvasID);
        const myDrawingContext = myCanvasElement.getContext('2d'); 

        // Corrected path for three symmetrical peaks (10 points, 9 segments)
        const myPathPoints = [
            { x: 50, y: 150 },   // 0: Start Point (Bottom-Left)
            { x: 50, y: 80 },    // 1: Left Side Top
            { x: 70, y: 60 },    // 2: Peak 1
            { x: 110, y: 80 },   // 3: Valley 1
            { x: 150, y: 60 },   // 4: Peak 2
            { x: 190, y: 80 },   // 5: Valley 2
            { x: 230, y: 60 },   // 6: Peak 3
            { x: 250, y: 80 },   // 7: Right Side Top
            { x: 250, y: 150 },  // 8: Right Side Bottom
            { x: 50, y: 150 }    // 9: Final Close (Base line)
        ];

        // --- Animation Tracking Variables ---
        let mySegmentIndex = 0;       
        let mySegmentProgress = 0.0;  
        const myAnimationSpeed = 0.02; // Marker speed

        // --- Drawing Styles ---
        myDrawingContext.strokeStyle = 'gold'; 
        myDrawingContext.lineWidth = 4;
        myDrawingContext.lineJoin = 'round'; 

        // --- HELPER FUNCTION: Draws the complete crown outline once ---
        function myDrawFullCrownLine() {
            myDrawingContext.beginPath();
            myDrawingContext.moveTo(myPathPoints[0].x, myPathPoints[0].y);
            for (let i = 1; i < myPathPoints.length; i++) {
                myDrawingContext.lineTo(myPathPoints[i].x, myPathPoints[i].y);
            }
            myDrawingContext.stroke();
        }

        // --- NEW FUNCTION: The marker loop that runs after the crown is fully drawn ---
        function myLoopMarker() {
            // 1. Clear only the area around the previous marker position (for simplicity, we'll clear the whole canvas and redraw the crown)
            myDrawingContext.clearRect(0, 0, myCanvasElement.width, myCanvasElement.height);

            // 2. Redraw the full crown line every frame
            myDrawFullCrownLine(); 

            // Check if we reached the end of the entire path
            if (mySegmentIndex >= myPathPoints.length - 1) {
                mySegmentIndex = 0;      // <--- THE LOOP: Reset to the first segment (0)
                mySegmentProgress = 0;
            }

            // Get the start and end points of the current segment
            const myStartPoint = myPathPoints[mySegmentIndex];
            const myEndPoint = myPathPoints[mySegmentIndex + 1];

            // 3. Calculate the Marker Position (Interpolation)
            const myCurrentX = myStartPoint.x + (myEndPoint.x - myStartPoint.x) * mySegmentProgress;
            const myCurrentY = myStartPoint.y + (myEndPoint.y - myStartPoint.y) * mySegmentProgress;

            // 4. Draw the Marker (a small red circle)
            myDrawingContext.beginPath();
            myDrawingContext.arc(myCurrentX, myCurrentY, 5, 0, Math.PI * 2); 
            myDrawingContext.fillStyle = 'red'; 
            myDrawingContext.fill();

            // 5. Update Progress
            mySegmentProgress += myAnimationSpeed;

            // If we reached the end of the current segment (Progress > 1.0)
            if (mySegmentProgress >= 1.0) {
                mySegmentIndex++;       // Move to the next segment
                mySegmentProgress = 0;  // Reset progress
            }

            requestAnimationFrame(myLoopMarker);
        }

        // --- Main Animation Function (Only runs once to draw the line initially) ---
        function myAnimateCrown() {
            // This function is still needed to draw the line during the first pass
            myDrawingContext.clearRect(0, 0, myCanvasElement.width, myCanvasElement.height);

            // Draw the completed line segments and the current segment (like before)
            myDrawingContext.beginPath();
            myDrawingContext.moveTo(myPathPoints[0].x, myPathPoints[0].y);
            for (let i = 1; i <= mySegmentIndex + 1 && i < myPathPoints.length; i++) {
                myDrawingContext.lineTo(myPathPoints[i].x, myPathPoints[i].y);
            }
            myDrawingContext.stroke();
            
            // Draw the Marker (as before)
            const myStartPoint = myPathPoints[mySegmentIndex];
            const myEndPoint = myPathPoints[mySegmentIndex + 1];
            const myCurrentX = myStartPoint.x + (myEndPoint.x - myStartPoint.x) * mySegmentProgress;
            const myCurrentY = myStartPoint.y + (myEndPoint.y - myStartPoint.y) * mySegmentProgress;
            myDrawingContext.beginPath();
            myDrawingContext.arc(myCurrentX, myCurrentY, 5, 0, Math.PI * 2); 
            myDrawingContext.fillStyle = 'red'; 
            myDrawingContext.fill();

            // ----------------------------------------------------
            // Check for completion of the initial drawing phase
            // ----------------------------------------------------
            if (mySegmentIndex >= myPathPoints.length - 1) {
                // Initial drawing is complete!
                myDrawFullCrownLine(); // Ensure the final line is solid
                mySegmentIndex = 0;    // Reset for the loop
                mySegmentProgress = 0;
                myLoopMarker();        // Start the continuous loop
                return;                // Stop the initial animation
            }
            
            // Update Progress (only for initial phase)
            mySegmentProgress += myAnimationSpeed;
            if (mySegmentProgress >= 1.0) {
                mySegmentIndex++;
                mySegmentProgress = 0;
            }

            requestAnimationFrame(myAnimateCrown);
        }

        // Start the initial drawing
        myAnimateCrown();
    </script>
</body>
</html>

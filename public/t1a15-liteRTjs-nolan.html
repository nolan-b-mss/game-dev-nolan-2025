<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unified FOMO & Classification Detector</title>

    <style>
        body { 
            font-family: 'Inter', sans-serif;
            margin: 20px; 
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #myMainContainer {
            max-width: 800px;
            width: 100%;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
        }
        h1 {
            text-align: center;
            color: #3c4043;
            font-size: 2em;
            margin-bottom: 10px;
        }
        #myInstructions {
            text-align: center;
            color: #5f6368;
            margin-bottom: 20px;
            font-size: 0.95em;
        }
        #myVideo { 
            display: none; 
        }
        .myButton {
            background-color: #1a73e8; 
            color: white; 
            padding: 12px 24px; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            font-size: 16px; 
            margin: 5px;
            transition: background-color 0.3s, transform 0.1s;
            font-weight: 600;
        }
        .myButton:hover { 
            background-color: #155cb8; 
        }
        .myButton:active {
            transform: translateY(1px);
        }
        .myButton:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .myButton.stop {
            background-color: #d93025;
        }
        .myButton.stop:hover {
            background-color: #b02419;
        }
        #myControlSection {
            text-align: center;
            margin-bottom: 20px;
        }
        #myStatusMessage {
            font-size: 1em;
            margin: 15px 0;
            color: #3c4043;
            font-weight: 500;
            text-align: center;
            padding: 12px;
            background-color: #e6f7ff;
            border: 1px solid #90caff;
            border-radius: 8px;
        }
        #myCanvasContainer {
            position: relative;
            text-align: center;
            margin-top: 20px;
        }
        #myCanvas { 
            border: 3px solid #1a73e8;
            border-radius: 8px; 
            background-color: #333; 
            width: 100%; 
            height: auto;
            max-width: 600px; 
            aspect-ratio: 1 / 1;
            display: block;
            margin: 0 auto;
            transition: border-color 0.3s;
        }
        #myCanvas.drag-over {
            border-color: #0f9d58;
            border-style: dashed;
            border-width: 4px;
            background-color: #e8f5e9;
        }
        #myDropOverlay {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 600px;
            height: 100%;
            background-color: rgba(15, 157, 88, 0.1);
            border: 4px dashed #0f9d58;
            border-radius: 8px;
            display: none;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }
        #myDropOverlay.active {
            display: flex;
        }
        #myDropText {
            font-size: 1.5em;
            font-weight: bold;
            color: #0f9d58;
            background-color: white;
            padding: 20px 40px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .myModelInfo {
            text-align: center;
            margin-top: 15px;
            padding: 12px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .myInfoLabel {
            font-size: 0.85em;
            color: #6c757d;
            font-weight: 600;
            display: block;
            margin-bottom: 5px;
        }
        .myInfoValue {
            font-size: 0.95em;
            color: #212529;
            font-family: monospace;
        }
        .myInputGroup {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        .myInputGroup input[type="text"] {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 16px;
        }
        #myLabelEditor {
            width: 100%;
            height: 80px;
            padding: 10px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
            margin-bottom: 15px;
        }
        #myResultDisplay {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            background-color: #e6ffe6;
            border: 2px solid #0f9d58;
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            color: #0f9d58;
            display: none;
        }
        #myResultDisplay.active {
            display: block;
        }
        #myResultLabel {
            font-size: 1.8em;
            color: #0c8046;
            margin-top: 5px;
            display: block;
        }
        #myResultConfidence {
            font-size: 1em;
            color: #3c4043;
            display: block;
            margin-top: 5px;
        }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-tflite@0.0.1-alpha.9/dist/tf-tflite.min.js"></script>
</head>
<body>

    <script>
        // =================================================================
        // üöÄ DEFAULT CONFIGURATION (FOMO Model)
        // =================================================================
        const myDefaultConfig = {
            myDefaultUrl: "https://raw.githubusercontent.com/nolan-b-mss/game-dev-nolan-2025/public/ei-nolan.b.2025-project-1-classifier-tensorflow-lite-float32-model.7.tflite",
            myInputResolution: 96,
            myGridScaleFactor: 8,
            myConfidenceThreshold: 0.5,
            myClassLabels: ['unknown','pen'],
            myInputChannels: 1,
            myModelType: 'classification', // 'fomo' or 'classification'
            myGithubRepoPath: 'hpssjellis/my-examples-of-liteRTjs/main/public/tflite' // user/repo/branch/path
        };

        // =================================================================
        // ‚öôÔ∏è GLOBAL VARIABLES 
        // =================================================================
        let myVideoElement = null;
        let myIsWebcamReady = false;
        let myAnimationFrameId = null;
        let myStatusElement = null;
        let myStartButton = null;
        let myStopButton = null;
        let myCanvas = null;
        let myContext = null;
        let myDropOverlay = null;
        let myModelInfo = null;
        let myUrlInput = null;
        let myFileInput = null;
        let myLabelEditor = null;
        let myResultDisplay = null;
        let myModelSelect = null;
        
        let myModel = null;
        let myCurrentConfig = {...myDefaultConfig};
        let myCurrentModelName = 'Default Model';
        let myCurrentModelSize = 0;

        // =================================================================
        // üè† HTML SETUP
        // =================================================================
        
        function myCreateDOM() {
            const myMainContainer = document.createElement('div');
            myMainContainer.id = 'myMainContainer';
            
            const myTitle = document.createElement('h1');
            myTitle.textContent = 'Edge Impulse Model Detector';
            myMainContainer.appendChild(myTitle);

            const myInstructions = document.createElement('div');
            myInstructions.id = 'myInstructions';
            myInstructions.innerHTML = 'Load FOMO or Classification models via URL, File, or Drag & Drop<br><small>Auto-detects model type and properties. Edit labels below.</small>';
            myMainContainer.appendChild(myInstructions);

            // Model Select Dropdown
            myModelSelect = document.createElement('select');
            myModelSelect.style.cssText = 'width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 8px; font-size: 16px; background-color: white; margin-bottom: 15px;';
            myModelSelect.innerHTML = '<option value="">Loading models from GitHub...</option>';
            myModelSelect.onchange = myHandleModelSelect;
            myMainContainer.appendChild(myModelSelect);

            // URL Upload
            const myUrlGroup = document.createElement('div');
            myUrlGroup.className = 'myInputGroup';
            myUrlInput = document.createElement('input');
            myUrlInput.type = 'text';
            myUrlInput.placeholder = 'Paste Model URL (.tflite or .lite)';
            myUrlInput.value = myDefaultConfig.myDefaultUrl;
            myUrlGroup.appendChild(myUrlInput);
            const myUrlButton = document.createElement('button');
            myUrlButton.className = 'myButton';
            myUrlButton.textContent = 'Load from URL';
            myUrlButton.onclick = () => myLoadModelFromUrl(myUrlInput.value);
            myUrlGroup.appendChild(myUrlButton);
            myMainContainer.appendChild(myUrlGroup);

            // File Input
            myFileInput = document.createElement('input');
            myFileInput.type = 'file';
            myFileInput.style.marginBottom = '15px';
            myFileInput.setAttribute('accept', '.tflite,.lite');
            myFileInput.onchange = myHandleFileInput;
            myMainContainer.appendChild(myFileInput);

            // Model info display
            myModelInfo = document.createElement('div');
            myModelInfo.className = 'myModelInfo';
            myModelInfo.innerHTML = `
                <span class="myInfoLabel">Model:</span>
                <span class="myInfoValue" id="myModelName">No model loaded</span><br>
                <span class="myInfoLabel">Type:</span>
                <span class="myInfoValue" id="myModelType">Unknown</span><br>
                <span class="myInfoLabel">Size:</span>
                <span class="myInfoValue" id="myModelSize">N/A</span><br>
                <span class="myInfoLabel">Config:</span>
                <span class="myInfoValue" id="myModelConfig">N/A</span>
            `;
            myMainContainer.appendChild(myModelInfo);

            // Labels Textarea
            const myLabelHeader = document.createElement('div');
            myLabelHeader.style.cssText = 'font-size: 0.9em; margin-top: 15px; margin-bottom: 5px; font-weight: bold; color: #3c4043;';
            myLabelHeader.textContent = 'Class Labels (Comma-separated)';
            myMainContainer.appendChild(myLabelHeader);
            
            myLabelEditor = document.createElement('textarea');
            myLabelEditor.id = 'myLabelEditor';
            myLabelEditor.placeholder = 'Enter labels here (e.g., background, Object1, Object2)';
            myLabelEditor.oninput = myUpdateConfigFromLabels;
            myMainContainer.appendChild(myLabelEditor);

            // Control section
            const myControlSection = document.createElement('div');
            myControlSection.id = 'myControlSection';
            
            myStatusElement = document.createElement('div');
            myStatusElement.id = 'myStatusMessage';
            myStatusElement.textContent = 'Click "Start" to begin';
            myControlSection.appendChild(myStatusElement);

            myStartButton = document.createElement('button');
            myStartButton.className = 'myButton';
            myStartButton.textContent = 'Start Webcam & Load Default Model';
            myStartButton.onclick = myStartAll;
            myControlSection.appendChild(myStartButton);

            myStopButton = document.createElement('button');
            myStopButton.className = 'myButton stop';
            myStopButton.textContent = 'Stop Webcam';
            myStopButton.onclick = myStopAll;
            myStopButton.disabled = true;
            myControlSection.appendChild(myStopButton);

            myMainContainer.appendChild(myControlSection);

            // Hidden video element
            myVideoElement = document.createElement('video');
            myVideoElement.id = 'myVideo';
            myVideoElement.setAttribute('playsinline', '');
            myVideoElement.setAttribute('autoplay', '');
            myMainContainer.appendChild(myVideoElement);

            // Canvas container with drop overlay
            const myCanvasContainer = document.createElement('div');
            myCanvasContainer.id = 'myCanvasContainer';

            myCanvas = document.createElement('canvas');
            myCanvas.id = 'myCanvas';
            myCanvas.width = myCurrentConfig.myInputResolution;
            myCanvas.height = myCurrentConfig.myInputResolution;
            myContext = myCanvas.getContext('2d');
            myCanvasContainer.appendChild(myCanvas);

            myDropOverlay = document.createElement('div');
            myDropOverlay.id = 'myDropOverlay';
            const myDropText = document.createElement('div');
            myDropText.id = 'myDropText';
            myDropText.textContent = 'Drop .tflite or .lite file here';
            myDropOverlay.appendChild(myDropText);
            myCanvasContainer.appendChild(myDropOverlay);

            myMainContainer.appendChild(myCanvasContainer);

            // Classification Result Display
            myResultDisplay = document.createElement('div');
            myResultDisplay.id = 'myResultDisplay';
            myResultDisplay.innerHTML = 'Classification Result:<span id="myResultLabel">Awaiting Input...</span><span id="myResultConfidence"></span>';
            myMainContainer.appendChild(myResultDisplay);

            document.body.appendChild(myMainContainer);

            mySetupDragAndDrop();
            myUpdateLabelEditor();
            myLoadGithubModels(); // Load models from GitHub
        }

        window.onload = myCreateDOM;

        // =================================================================
        // üì¶ GITHUB MODEL LOADER
        // =================================================================

        async function myLoadGithubModels() {
            try {
                // Parse the GitHub path
                const myPathParts = myDefaultConfig.myGithubRepoPath.split('/');
                const myUser = myPathParts[0];
                const myRepo = myPathParts[1];
                const myBranch = myPathParts[2];
                const myFolderPath = myPathParts.slice(3).join('/');
                
                // GitHub API URL
                const myApiUrl = `https://api.github.com/repos/${myUser}/${myRepo}/contents/${myFolderPath}?ref=${myBranch}`;
                
                console.log('Fetching models from:', myApiUrl);
                
                const myResponse = await fetch(myApiUrl);
                if (!myResponse.ok) {
                    throw new Error(`GitHub API error: ${myResponse.status}`);
                }
                
                const myFiles = await myResponse.json();
                
                // Filter for .tflite and .lite files
                const myModelFiles = myFiles.filter(myFile => 
                    myFile.name.endsWith('.tflite') || myFile.name.endsWith('.lite')
                );
                
                if (myModelFiles.length === 0) {
                    myModelSelect.innerHTML = '<option value="">No models found in repository</option>';
                    return;
                }
                
                // Populate select box
                myModelSelect.innerHTML = '<option value="">-- Select a Model --</option>';
                
                myModelFiles.forEach(myFile => {
                    const myOption = document.createElement('option');
                    
                    // Build proper GitHub Pages URL
                    // Format: https://username.github.io/repository/path/to/file
                    const myGithubPagesUrl = `https://${myUser}.github.io/${myRepo}/${myFolderPath}/${myFile.name}`;
                    
                    myOption.value = myGithubPagesUrl;
                    myOption.textContent = myFile.name;
                    myModelSelect.appendChild(myOption);
                });
                
                console.log(`Loaded ${myModelFiles.length} models from GitHub`);
                
            } catch (myError) {
                console.error('Failed to load GitHub models:', myError);
                myModelSelect.innerHTML = '<option value="">Failed to load models (check console)</option>';
            }
        }

        function myHandleModelSelect() {
            if (myModelSelect.value) {
                myUrlInput.value = myModelSelect.value;
                // Automatically load the selected model
                myLoadModelFromUrl(myModelSelect.value);
            }
        }

        // =================================================================
        // üéØ DRAG AND DROP / FILE INPUT HANDLERS
        // =================================================================

        function mySetupDragAndDrop() {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(myEventName => {
                document.body.addEventListener(myEventName, myPreventDefaults, false);
            });

            function myPreventDefaults(myEvent) {
                myEvent.preventDefault();
                myEvent.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(myEventName => {
                myCanvas.addEventListener(myEventName, () => {
                    myCanvas.classList.add('drag-over');
                    myDropOverlay.classList.add('active');
                }, false);
            });

            ['dragleave', 'drop'].forEach(myEventName => {
                myCanvas.addEventListener(myEventName, () => {
                    myCanvas.classList.remove('drag-over');
                    myDropOverlay.classList.remove('active');
                }, false);
            });

            myCanvas.addEventListener('drop', myHandleDrop, false);
        }

        function myHandleDrop(myEvent) {
            const myDataTransfer = myEvent.dataTransfer;
            const myDroppedFiles = myDataTransfer.files;

            if (myDroppedFiles.length > 0) {
                const myFile = myDroppedFiles[0];
                if (myFile.name.endsWith('.tflite') || myFile.name.endsWith('.lite')) {
                    myLoadModelFromFile(myFile);
                } else {
                    myStatusElement.textContent = 'Error: Please drop a .tflite or .lite file';
                }
            }
        }
        
        function myHandleFileInput(myEvent) {
            const myFile = myEvent.target.files[0];
            if (myFile) {
                myLoadModelFromFile(myFile);
            }
        }

        // =================================================================
        // üîç CONFIGURATION AND LABEL MANAGEMENT
        // =================================================================

        function myAutoDetectConfig(myModel) {
            try {
                const myDetectedConfig = {...myDefaultConfig};
                
                // Detect Input Size and Channels
                if (myModel.inputs && myModel.inputs.length > 0) {
                    const myInput = myModel.inputs[0];
                    if (myInput.shape && myInput.shape.length === 4) {
                        const myHeight = myInput.shape[1];
                        const myWidth = myInput.shape[2];
                        const myChannels = myInput.shape[3];
                        if (myHeight === myWidth && myHeight > 0) myDetectedConfig.myInputResolution = myHeight;
                        if (myChannels === 1 || myChannels === 3) myDetectedConfig.myInputChannels = myChannels;
                    }
                }
                
                // Detect Model Type from Output Shape
                if (myModel.outputs && myModel.outputs.length > 0) {
                    const myOutput = myModel.outputs[0];
                    
                    if (myOutput.shape.length === 4) {
                        // FOMO Model: [1, gridH, gridW, numClasses]
                        myDetectedConfig.myModelType = 'fomo';
                        
                        const myGridH = myOutput.shape[1];
                        const myNumClasses = myOutput.shape[3];
                        
                        if (myGridH > 0 && myDetectedConfig.myInputResolution > 0) {
                            const myCalculatedFactor = myDetectedConfig.myInputResolution / myGridH;
                            if (myCalculatedFactor > 0 && Number.isInteger(myCalculatedFactor)) {
                                myDetectedConfig.myGridScaleFactor = myCalculatedFactor;
                            }
                        }
                        
                        if (myNumClasses > 0 && myNumClasses !== myCurrentConfig.myClassLabels.length) {
                            myDetectedConfig.myClassLabels = ['background'];
                            for (let i = 1; i < myNumClasses; i++) {
                                myDetectedConfig.myClassLabels.push(`Object${i}`);
                            }
                        } else {
                            myDetectedConfig.myClassLabels = myCurrentConfig.myClassLabels;
                        }
                        
                    } else if (myOutput.shape.length === 2) {
                        // Classification Model: [1, numClasses]
                        myDetectedConfig.myModelType = 'classification';
                        
                        const myNumClasses = myOutput.shape[1];
                        
                        if (myNumClasses > 0 && myNumClasses !== myCurrentConfig.myClassLabels.length) {
                            myDetectedConfig.myClassLabels = [];
                            for (let i = 0; i < myNumClasses; i++) {
                                myDetectedConfig.myClassLabels.push(`Class${i}`);
                            }
                        } else {
                            myDetectedConfig.myClassLabels = myCurrentConfig.myClassLabels;
                        }
                    } else {
                        console.warn('Unknown output shape:', myOutput.shape);
                        myDetectedConfig.myModelType = 'unknown';
                    }
                }
                
                myCanvas.width = myDetectedConfig.myInputResolution;
                myCanvas.height = myDetectedConfig.myInputResolution;
                
                return myDetectedConfig;
                
            } catch (myError) {
                console.error('Auto-detection error:', myError);
                return {...myDefaultConfig};
            }
        }

        function myUpdateModelInfoDisplay() {
            document.getElementById('myModelName').textContent = myCurrentModelName;
            document.getElementById('myModelType').textContent = myCurrentConfig.myModelType.toUpperCase();
            
            // Format file size
            let mySizeText = 'N/A';
            if (myCurrentModelSize > 0) {
                if (myCurrentModelSize < 1024) {
                    mySizeText = `${myCurrentModelSize} bytes`;
                } else if (myCurrentModelSize < 1024 * 1024) {
                    mySizeText = `${(myCurrentModelSize / 1024).toFixed(2)} KB`;
                } else {
                    mySizeText = `${(myCurrentModelSize / (1024 * 1024)).toFixed(2)} MB`;
                }
            }
            document.getElementById('myModelSize').textContent = mySizeText;
            
            let myConfigText = `${myCurrentConfig.myInputResolution}x${myCurrentConfig.myInputResolution}, ` +
                `${myCurrentConfig.myInputChannels === 3 ? 'RGB' : 'Grayscale'}, ` +
                `Classes:${myCurrentConfig.myClassLabels.length}`;
            
            if (myCurrentConfig.myModelType === 'fomo') {
                myConfigText += `, Grid:${myCurrentConfig.myGridScaleFactor}`;
            }
            
            document.getElementById('myModelConfig').textContent = myConfigText;
            
            // Show/hide classification result display
            if (myCurrentConfig.myModelType === 'classification') {
                myResultDisplay.classList.add('active');
            } else {
                myResultDisplay.classList.remove('active');
            }
            
            myUpdateLabelEditor();
        }
        
        function myUpdateLabelEditor() {
            if (myLabelEditor) {
                myLabelEditor.value = myCurrentConfig.myClassLabels.join(', ');
            }
        }
        
        function myUpdateConfigFromLabels() {
            if (myLabelEditor) {
                const myNewLabels = myLabelEditor.value
                    .split(',')
                    .map(myLabel => myLabel.trim())
                    .filter(myLabel => myLabel.length > 0);
                
                if (myNewLabels.length === myCurrentConfig.myClassLabels.length) {
                    myCurrentConfig.myClassLabels = myNewLabels;
                    console.log('Labels updated manually:', myCurrentConfig.myClassLabels);
                } else if (myModel) {
                    myStatusElement.textContent = `Warning: Label count must be ${myCurrentConfig.myClassLabels.length}. Current: ${myNewLabels.length}`;
                }
            }
        }

        // =================================================================
        // üíª MODEL LOADING
        // =================================================================

        async function myLoadModel(mySource, myModelName) {
            try {
                myModel = await tflite.loadTFLiteModel(mySource);
                myCurrentModelName = myModelName;
                
                myCurrentConfig = myAutoDetectConfig(myModel);
                myUpdateModelInfoDisplay();
                
                console.log(`Model loaded: ${myModelName} (Type: ${myCurrentConfig.myModelType})`);
                myStatusElement.textContent = `Model loaded: ${myModelName} (${myCurrentConfig.myModelType.toUpperCase()})`;
            } catch (myError) {
                console.error('Model loading error:', myError);
                throw new Error(`Failed to load model: ${myError.message.substring(0, 100)}...`);
            }
        }
        
        async function myLoadModelFromUrl(myUrl) {
            if (!myUrl.endsWith('.tflite') && !myUrl.endsWith('.lite')) {
                 myStatusElement.textContent = 'Error: URL must end with .tflite or .lite';
                 return;
            }
            myStatusElement.textContent = `Loading model from URL...`;
            try {
                // Fetch to get file size
                const myResponse = await fetch(myUrl);
                const myBlob = await myResponse.blob();
                myCurrentModelSize = myBlob.size;
                
                await myLoadModel(myUrl, myUrl.substring(myUrl.lastIndexOf('/') + 1));
                if (myIsWebcamReady) myStatusElement.textContent += ' (Inference running)';
            } catch (myError) {
                 myStatusElement.textContent = `Error: ${myError.message}`;
            }
        }

        async function myLoadModelFromFile(myFile) {
            myStatusElement.textContent = `Loading model from file: ${myFile.name}...`;
            
            try {
                myCurrentModelSize = myFile.size;
                
                const myArrayBuffer = await new Promise((myResolve, myReject) => {
                    const myReader = new FileReader();
                    myReader.onload = () => myResolve(myReader.result);
                    myReader.onerror = myReject;
                    myReader.readAsArrayBuffer(myFile);
                });

                myModel = await tflite.loadTFLiteModel(myArrayBuffer);
                myCurrentModelName = myFile.name;
                
                myCurrentConfig = myAutoDetectConfig(myModel);
                myUpdateModelInfoDisplay();
                
                myStatusElement.textContent = `Model loaded: ${myFile.name} (${myCurrentConfig.myModelType.toUpperCase()})`;
                
                if (myIsWebcamReady) {
                    myStatusElement.textContent += ' (Inference running)';
                } else {
                    myStatusElement.textContent += '. Start webcam to run inference.';
                }
            } catch (myError) {
                myStatusElement.textContent = `Failed to load ${myFile.name}. Check console.`;
                console.error('File loading error:', myError);
            }
        }

       // =================================================================
        // üöÄ START/STOP & INFERENCE
        // =================================================================

        async function myStartAll() {
            myStartButton.disabled = true;
            myStatusElement.textContent = 'Loading default model...';

            try {
                if (!myModel) {
                     await myLoadModel(myDefaultConfig.myDefaultUrl, 'Default Model');
                }
                myStatusElement.textContent = 'Model loaded! Starting webcam...';
                
                await myStartWebcam();
                
                myStatusElement.textContent = `Running ${myCurrentConfig.myModelType} inference...`;
                myStopButton.disabled = false;
                
            } catch (myError) {
                myStatusElement.textContent = `Error: ${myError.message}`;
                console.error('Startup error:', myError);
                myStartButton.disabled = false;
            }
        }
        
        async function myStartWebcam() {
            if (myIsWebcamReady) return;

            try {
                const myStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: 640,
                        height: 640,
                        facingMode: 'user'
                    },
                    audio: false
                });

                myVideoElement.srcObject = myStream;
                await new Promise(myResolve => myVideoElement.onloadedmetadata = myResolve); 
                myVideoElement.play();
                myIsWebcamReady = true;
                
                console.log('Webcam started');
                myRunInferenceLoop();
            } catch (myError) {
                console.error('Webcam error:', myError);
                throw new Error(`Webcam access failed: ${myError.message}`);
            }
        }

        function myStopWebcam() {
            if (myAnimationFrameId) {
                cancelAnimationFrame(myAnimationFrameId);
                myAnimationFrameId = null;
            }
            if (myVideoElement && myVideoElement.srcObject) {
                myVideoElement.srcObject.getTracks().forEach(myTrack => myTrack.stop());
                myVideoElement.srcObject = null;
            }
            myIsWebcamReady = false;
        }

        function myRunInferenceLoop() {
            if (!myIsWebcamReady || !myModel) {
                myAnimationFrameId = requestAnimationFrame(myRunInferenceLoop);
                return;
            }

            tf.tidy(() => {
                const myInputSize = myCurrentConfig.myInputResolution;
                
                myContext.drawImage(myVideoElement, 0, 0, myInputSize, myInputSize);
                
                let myInputTensor = tf.browser.fromPixels(myCanvas, myCurrentConfig.myInputChannels);
                let myNormalizedTensor = myInputTensor
                    .resizeBilinear([myInputSize, myInputSize])
                    .cast('float32')
                    .div(255.0)
                    .expandDims(0);

                const myOutputTensor = myModel.predict(myNormalizedTensor);
                
                // Route to appropriate post-processing based on model type
                if (myCurrentConfig.myModelType === 'fomo') {
                    myPostProcessFomo(myOutputTensor);
                } else if (myCurrentConfig.myModelType === 'classification') {
                    myPostProcessClassification(myOutputTensor);
                }
            });

            myAnimationFrameId = requestAnimationFrame(myRunInferenceLoop);
        }

        // =================================================================
        // üìä POST-PROCESSING FUNCTIONS
        // =================================================================

        function myPostProcessFomo(myOutputTensor) {
            const myPredictionData = myOutputTensor.dataSync();
            const myOutputShape = myOutputTensor.shape;
            const myNumClasses = myOutputShape[3];
            const myGridX = myOutputShape[1];
            const myGridY = myOutputShape[2];

            const myInputSize = myCurrentConfig.myInputResolution;
            const myGridSize = myInputSize / myCurrentConfig.myGridScaleFactor;

            if (myCurrentConfig.myClassLabels.length !== myNumClasses) {
                 myStatusElement.textContent = `ERROR: Label count (${myCurrentConfig.myClassLabels.length}) != Model classes (${myNumClasses})`;
                 return;
            }

            myContext.drawImage(myVideoElement, 0, 0, myInputSize, myInputSize);

            for (let i = 0; i < myGridSize; i++) {
                for (let j = 0; j < myGridSize; j++) {
                    const myCellStartIndex = (i * myGridSize * myNumClasses) + (j * myNumClasses);

                    let myMaxProbability = 0;
                    let myMaxClassIndex = 0;

                    for (let k = 0; k < myNumClasses; k++) {
                        const myProbability = myPredictionData[myCellStartIndex + k];
                        if (myProbability > myMaxProbability) {
                            myMaxProbability = myProbability;
                            myMaxClassIndex = k;
                        }
                    }

                    if (myMaxClassIndex !== 0 && myMaxProbability >= myCurrentConfig.myConfidenceThreshold) {
                        const myCentroidX = (j * myCurrentConfig.myGridScaleFactor) + (myCurrentConfig.myGridScaleFactor / 2);
                        const myCentroidY = (i * myCurrentConfig.myGridScaleFactor) + (myCurrentConfig.myGridScaleFactor / 2);
                        const myLabel = myCurrentConfig.myClassLabels[myMaxClassIndex] || `Class${myMaxClassIndex}`;
                        
                        myContext.fillStyle = myMaxClassIndex % 2 === 1 ? 'rgba(255, 69, 0, 0.8)' : 'rgba(50, 205, 50, 0.8)';
                        myContext.fillRect(myCentroidX - 5, myCentroidY - 5, 10, 10);
                        
                        myContext.font = '12px Arial';
                        myContext.fillStyle = 'white';
                        myContext.textAlign = 'center';
                        myContext.fillText(myLabel, myCentroidX, myCentroidY - 8);
                    }
                }
            }
        }

        function myPostProcessClassification(myOutputTensor) {
            const myNumClasses = myCurrentConfig.myClassLabels.length;
            
            if (myOutputTensor.shape[1] !== myNumClasses) {
                 myStatusElement.textContent = `ERROR: Model output (${myOutputTensor.shape[1]}) != Label count (${myNumClasses})`;
                 return;
            }

            const myResult = myOutputTensor.squeeze().arraySync();
            
            let myMaxProbability = 0;
            let myMaxClassIndex = 0;
            
            for (let i = 0; i < myResult.length; i++) {
                if (myResult[i] > myMaxProbability) {
                    myMaxProbability = myResult[i];
                    myMaxClassIndex = i;
                }
            }
            
            const myLabel = myCurrentConfig.myClassLabels[myMaxClassIndex];
            const myConfidence = (myMaxProbability * 100).toFixed(2);
            
            document.getElementById('myResultLabel').textContent = myLabel.toUpperCase();
            document.getElementById('myResultConfidence').textContent = `${myConfidence}% Confidence`;

            console.log(`Classified: ${myLabel} (${myConfidence}%)`);
        }

        function myStopAll() {
            myStopWebcam();
            
            myContext.clearRect(0, 0, myCanvas.width, myCanvas.height);
            myContext.fillStyle = '#333';
            myContext.fillRect(0, 0, myCanvas.width, myCanvas.height);
            
            if (myCurrentConfig.myModelType === 'classification') {
                document.getElementById('myResultLabel').textContent = 'Awaiting Input...';
                document.getElementById('myResultConfidence').textContent = '';
            }
            
            myStatusElement.textContent = 'Stopped. Click "Start" or load a new model.';
            myStartButton.disabled = false;
            myStopButton.disabled = true;
            
            console.log('Stopped');
        }
    </script>

      <div>
        <h2>Reference</h2>
      
        <p>My main liteRTjs Index <a href="https://hpssjellis.github.io/my-examples-of-liteRTjs/public/index.html"> liteRTjs </a> </p>  
        <p>My liteRTjs Github <a href="https://github.com/hpssjellis/my-examples-of-liteRTjs"> my-examples-of-liteRTjs </a> </p>  
        <p>You can find more of my work on my <a href="https://github.com/hpssjellis"> hpssjellis </a> GitHub page:</p>
        <p> By Jeremy Ellis <a href="https://ca.linkedin.com/in/jeremy-ellis-4237a9bb"> LinkedIn </a><br></p>
    </div>
</body>
</html>
